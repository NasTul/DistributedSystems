For the verification of file access/modification permissions, all authoritative peers (AP) or authentication servers need to maintain a list of every peers' access level, means what kind of file a peer can read or write. And APs own the public key and identity of all peers. This list can also be maintained by all peers (not limited to APs), but it will increase the difficulty of maintaining the list. Since our BitBox does not have the AP system, the second way will be adopted below (ie each The peer has a list of access rights for each type of access level file it owns. The update operation for the access permission list is similar to the write permission management and will be mentioned below.

Read files: Authentication is required before getting the directories and files. Assume that peer A wants to establish a connection with peer B and synchronize the directory to read the file. It needs to send the unencrypted identity information of peer A to peer B first. At this point, B can directly query the file accessible by A and generate the directory and send it to A using the public_key kAPub of A. But for our BitBox system, B will generate an AES key and use A's public_key kAPub encryption to become {kABaes}_{kAPub}. A uses kAPriv decryption to obtain kABaes, then A and B can use kABaes for AES encrypted communication and obtains files from B. When B sends file F, AES encryption becomes {F}_{kABaes}, and A receives it and decrypts it. Symmetric encryption using AES can greatly reduce the amount of computation compared to RSA asymmetric encryption.

Write files: If A needs to modify the file F, the operation of encrypting the entire file F requires a large amount of computation. Therefore, for files that can be accessed by all peers, the file can be digitally signed and sent in plaintext. Still using the communication between A and B,  A and B have established AES encrypted communication as described above, and A wants to send the modified file F to B. A converts the modified file F into a fixed length Digest(F) using the digest function, and encrypts it with kABaes. The encrypted information {Digest(F)}_ {kABaes} is directly attached with the unencrypted file F, and the information is F, {Digest(F)}_ {kABaes}. The B uses kABaes to decrypt {Digest(F)}_{kABaes} after receiving the message, and if F matches Digest(F) and A has the write permission, B will modify the file F. 
If A wants to modify a file with a higher read level, that is, a file that is not accessible to all peers, then the file F cannot be sent in clear text. So the way needed it is similar but different to reading the file, because B needs to verify the identity of A. Similar to the above, after A gets Digest(F), A needs to encrypt both Digest(F) and file F using AES to, which become {{F}_{kABaes}, {Digest(F)}_{kABaes}}. The reason why the {F}_{kABaes} is not sent directly is that the malicious peers can send the spam to corrupt the file F stored on B, so it is necessary to confirm the digital signature of A before modifying.

The addition and deletion of the read/write permission list is the same as the modification of the file, and digital signature verification is required, but the list itself may not be encrypted. Because the list can be exposed but only peers with permissions can modify it.

Existing problems: There is a vulnerability in the BitBox system because it has no authoritative peer. In the above communication between A and B, the attackers can pretend to be peer B, as long as the attacker holds A's public key kAPub to establish AES communication with A and transmit wrong files to A. To prevent this vulnerability, it needs to perform two-way authentication when establishing a connection. That is, before the AES connection is established, B needs to digitally sign the AES key sent by itself using its own private key kBPriv, and send P{{kABaes}_{kAPub}, {Digest(kABaes)}_{kBPriv}} instead of {kABaes}_{kAPub}. After receiving the message, A uses its own private key kAPriv to decrypt {kABaes}_{kAPub} then get kABaes and use B's public key kBPub to decrypt {Digest(kABaes)}_{kBPriv} to get Digest(kABaes). Communication is performed after verifying the digital signature, which allows the identities of A and B to be mutually confirmed.

